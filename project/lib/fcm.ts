// lib/fcm.tsimport { getMessaging, getToken, onMessage, setBackgroundMessageHandler, getInitialNotification, onNotificationOpenedApp, onTokenRefresh, requestPermission, AuthorizationStatus } from '@react-native-firebase/messaging';import { Platform, Alert, Linking, PermissionsAndroid } from 'react-native';import AsyncStorage from '@react-native-async-storage/async-storage';import { apiService } from './api';import * as Notifications from 'expo-notifications';const FCM_TOKEN_KEY = 'fcm_token';/** * Request notification permissions for FCM using modern approach */export const requestNotificationPermission = async (): Promise<boolean> => {  try {    // For Android 13+ (API level 33+), request POST_NOTIFICATIONS permission    if (Platform.OS === 'android' && Platform.Version >= 33) {      const granted = await PermissionsAndroid.request(        PermissionsAndroid.PERMISSIONS.POST_NOTIFICATIONS,        {          title: 'Notification Permission',          message: 'This app needs access to send you notifications',          buttonNeutral: 'Ask Me Later',          buttonNegative: 'Cancel',          buttonPositive: 'OK',        }      );      if (granted !== PermissionsAndroid.RESULTS.GRANTED) {        return false;      }    }    // Use Expo Notifications for cross-platform permission handling    const { status: existingStatus } = await Notifications.getPermissionsAsync();    let finalStatus = existingStatus;    if (existingStatus !== 'granted') {      const { status } = await Notifications.requestPermissionsAsync({        ios: {          allowAlert: true,          allowBadge: true,          allowSound: true,        },      });      finalStatus = status;    }    if (finalStatus !== 'granted') {      // Show alert only if user explicitly denied      setTimeout(() => {        Alert.alert(          'Enable Notifications',          'Stay updated with likes, comments, and messages! You can enable notifications in Settings.',          [            { text: 'Not Now', style: 'cancel' },            { text: 'Open Settings', onPress: () => Linking.openSettings() }          ]        );      }, 500);      return false;    }    // Also try Firebase messaging permission for FCM tokens    try {      const messaging = getMessaging();      const authStatus = await requestPermission(messaging);      } catch (fcmError) {      }    return true;  } catch (error) {    return false;  }};/** * Get FCM token and save it to backend * Note: This assumes permission was already requested during login/registration */export const getFCMToken = async (): Promise<string | null> => {  try {    // Get FCM token (permission should already be granted from login)    const messaging = getMessaging();    const fcmToken = await getToken(messaging);    if (!fcmToken) {      return null;    }    // Store token locally    await AsyncStorage.setItem(FCM_TOKEN_KEY, fcmToken);    // Send token to backend    await saveFCMTokenToBackend(fcmToken);    return fcmToken;  } catch (error: any) {    // Handle SERVICE_NOT_AVAILABLE gracefully    if (error?.message?.includes('SERVICE_NOT_AVAILABLE')) {      // Retry once after delay      setTimeout(async () => {        try {          const messaging = getMessaging();          const token = await getToken(messaging);          if (token) {            await AsyncStorage.setItem(FCM_TOKEN_KEY, token);            await saveFCMTokenToBackend(token);            }        } catch (retryError) {          }      }, 5000);    }    return null;  }};/** * Save FCM token to backend */const saveFCMTokenToBackend = async (token: string): Promise<void> => {  try {    const platform = Platform.OS;    const response = await apiService.saveFCMToken(token, platform);    if (response.message) {      } else {      }  } catch (error) {    }};/** * Remove FCM token from backend (on logout) */export const removeFCMToken = async (): Promise<void> => {  try {    const token = await AsyncStorage.getItem(FCM_TOKEN_KEY);    if (!token) return;    await apiService.removeFCMToken(token);    await AsyncStorage.removeItem(FCM_TOKEN_KEY);    } catch (error) {    }};/** * Initialize FCM listeners */export const initializeFCM = (onNotificationReceived?: (notification: any) => void) => {  // Handle notification when app is in background/quit state  const messaging = getMessaging();  setBackgroundMessageHandler(messaging, async (remoteMessage) => {    });  // Handle notification when app is in foreground  const unsubscribeForeground = onMessage(messaging, async (remoteMessage) => {    if (onNotificationReceived) {      onNotificationReceived(remoteMessage);    }    // Show local notification when app is in foreground    if (remoteMessage.notification) {      Alert.alert(        remoteMessage.notification.title || 'Notification',        remoteMessage.notification.body || '',        [          { text: 'Dismiss', style: 'cancel' },          {             text: 'View',             onPress: () => handleNotificationPress(remoteMessage.data)          }        ]      );    }  });  // Handle notification press (when app is opened from notification)  const unsubscribeNotificationOpen = onNotificationOpenedApp(messaging, (remoteMessage) => {    handleNotificationPress(remoteMessage.data);  });  // Handle notification press when app was quit  getInitialNotification(messaging)    .then((remoteMessage) => {      if (remoteMessage) {        handleNotificationPress(remoteMessage.data);      }    });  // Handle token refresh  const unsubscribeTokenRefresh = onTokenRefresh(messaging, (fcmToken) => {    saveFCMTokenToBackend(fcmToken);  });  // Return cleanup function  return () => {    unsubscribeForeground();    unsubscribeNotificationOpen();    unsubscribeTokenRefresh();  };};/** * Handle notification press - navigate to specific post */const handleNotificationPress = (data: any) => {  if (!data) return;  const { postId, type } = data;  if (postId && type) {    // Import router dynamically to avoid circular dependencies    import('expo-router').then(({ router }) => {      try {        // Navigate to the specific post        if (type === 'comment') {          // The post screen can check for this param and scroll to comments          router.push(`/post/${postId}?scrollToComments=true`);        } else {          router.push(`/post/${postId}`);        }      } catch (error) {        // Fallback to home screen        router.push('/');      }    }).catch(error => {      });  }};/** * Check if FCM is supported on this device */export const isFCMSupported = (): boolean => {  return Platform.OS === 'android' || Platform.OS === 'ios';};/** * Get stored FCM token from AsyncStorage */export const getStoredFCMToken = async (): Promise<string | null> => {  try {    return await AsyncStorage.getItem(FCM_TOKEN_KEY);  } catch (error) {    return null;  }};