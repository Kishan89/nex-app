import { AppState, Platform } from 'react-native';import * as Notifications from 'expo-notifications';import { getMessaging, getToken, onMessage, setBackgroundMessageHandler, onNotificationOpenedApp, getInitialNotification } from '@react-native-firebase/messaging';import { router } from 'expo-router';import AsyncStorage from '@react-native-async-storage/async-storage';interface FCMData {  type?: 'message' | 'like' | 'comment' | 'follow';  chatId?: string;  postId?: string;  userId?: string;  messageId?: string;  username?: string;}export class CleanFCMService {  private static instance: CleanFCMService;  private isInitialized = false;  private fcmToken: string | null = null;  private unsubscribeForeground: (() => void) | null = null;  static getInstance(): CleanFCMService {    if (!CleanFCMService.instance) {      CleanFCMService.instance = new CleanFCMService();    }    return CleanFCMService.instance;  }  async initialize(): Promise<void> {    if (this.isInitialized) {      return;    }    try {      // Configure notification handler      this.configureNotificationHandler();      // Set up background message handler      this.setupBackgroundHandler();      // Set up foreground message handler      this.setupForegroundHandler();      // Set up notification tap handler      this.setupNotificationTapHandler();      // Register for FCM token      await this.registerForNotifications();      this.isInitialized = true;      } catch (error) {      }  }  private configureNotificationHandler(): void {    // Configure how notifications are displayed    Notifications.setNotificationHandler({      handleNotification: async (notification) => {        const appState = AppState.currentState;        const data = notification.request.content.data as FCMData;        // Show notifications only when app is not active        const shouldShow = appState !== 'active';        return {          shouldShowBanner: shouldShow,          shouldShowList: shouldShow,          shouldPlaySound: shouldShow,          shouldSetBadge: true,          priority: Notifications.AndroidNotificationPriority.HIGH,        };      },    });  }  private setupBackgroundHandler(): void {    // Handle notifications when app is in background or killed    setBackgroundMessageHandler(getMessaging(), async (remoteMessage) => {      const { notification, data } = remoteMessage;      if (!notification) {        return;      }      const notificationData = data as FCMData;      // Store notification data for deep linking when app opens      if (notificationData.chatId || notificationData.postId) {        try {          await AsyncStorage.setItem('pendingNotificationNavigation', JSON.stringify({            type: notificationData.type,            chatId: notificationData.chatId,            postId: notificationData.postId,            userId: notificationData.userId,            timestamp: Date.now()          }));          } catch (error) {          }      }      });  }  private setupForegroundHandler(): void {    const messaging = getMessaging();    // Handle notifications when app is in foreground    this.unsubscribeForeground = onMessage(messaging, async (remoteMessage) => {      const appState = AppState.currentState;      const data = remoteMessage.data as FCMData;      if (appState === 'active') {        // App is active - no system notification, only UI updates        // UI updates are handled by socket/real-time systems      } else {        }    });  }  private setupNotificationTapHandler(): void {    // Handle notification tap when app is opened from notification    onNotificationOpenedApp(getMessaging(), (remoteMessage) => {      const data = remoteMessage.data as FCMData;      this.handleNotificationTap(data);    });    // Handle initial notification if app was opened from killed state    getInitialNotification(getMessaging()).then(remoteMessage => {      if (remoteMessage) {        // Delay navigation to ensure app is fully loaded        setTimeout(() => {          const data = remoteMessage.data as FCMData;          this.handleNotificationTap(data);        }, 1500);      }    });    // Also handle Expo notifications tap    Notifications.addNotificationResponseReceivedListener(response => {      const data = response.notification.request.content.data as FCMData;      this.handleNotificationTap(data);    });  }  private async handleNotificationTap(data: FCMData): Promise<void> {    try {      // Navigate based on notification data      if (data.chatId) {        router.replace(`/chat/${data.chatId}`);      } else if (data.postId) {        router.replace(`/post/${data.postId}`);      } else if (data.userId) {        router.replace(`/profile/${data.userId}`);      } else {        }    } catch (error) {      }  }  private async registerForNotifications(): Promise<void> {    try {      const messaging = getMessaging();      // Get FCM token      this.fcmToken = await getToken(messaging);      if (this.fcmToken) {        // Store token for backend registration        await AsyncStorage.setItem('fcmToken', this.fcmToken);        } else {        }    } catch (error) {      }  }  /**   * Check and handle any pending navigation from background notifications   */  async checkPendingNavigation(): Promise<void> {    try {      const pendingData = await AsyncStorage.getItem('pendingNotificationNavigation');      if (pendingData) {        const data = JSON.parse(pendingData);        const timeDiff = Date.now() - data.timestamp;        // Only handle if less than 60 seconds old        if (timeDiff < 60000) {          await this.handleNotificationTap(data);        } else {          }        // Clear pending navigation        await AsyncStorage.removeItem('pendingNotificationNavigation');      }    } catch (error) {      }  }  /**   * Get FCM token for backend registration   */  getToken(): string | null {    return this.fcmToken;  }  /**   * Get service status for debugging   */  getStatus(): {    initialized: boolean;    hasToken: boolean;    appState: string;    tokenPreview: string;  } {    return {      initialized: this.isInitialized,      hasToken: !!this.fcmToken,      appState: AppState.currentState,      tokenPreview: this.fcmToken ? this.fcmToken.substring(0, 50) + '...' : 'No token'    };  }  /**   * Cleanup when app is closed   */  cleanup(): void {    if (this.unsubscribeForeground) {      this.unsubscribeForeground();      this.unsubscribeForeground = null;    }    this.isInitialized = false;    }}// Export singleton instanceexport const cleanFCMService = CleanFCMService.getInstance();export default cleanFCMService;