// lib/notificationNavigationService.tsimport * as Notifications from 'expo-notifications';import { router } from 'expo-router';import AsyncStorage from '@react-native-async-storage/async-storage';// Configure notification behaviorNotifications.setNotificationHandler({  handleNotification: async () => ({    shouldShowAlert: true,    shouldPlaySound: true,    shouldSetBadge: true,    shouldShowBanner: true,    shouldShowList: true,  }),});interface NotificationData {  type?: 'like' | 'comment' | 'message' | 'follow';  postId?: string;  chatId?: string;  userId?: string;  senderId?: string;  username?: string;  action?: string;  [key: string]: unknown; // Allow additional properties}class NotificationNavigationService {  private responseListenerSubscription: Notifications.Subscription | null = null;  private pendingNavigation: (() => void) | null = null;  private isNavigationReady: boolean = false;  private navigationReadyCallbacks: (() => void)[] = [];  constructor() {    this.setupNotificationResponseListener();  }  /**   * Initialize the notification navigation service   */  async initialize() {    // Check for notification permissions    const { status: existingStatus } = await Notifications.getPermissionsAsync();    let finalStatus = existingStatus;    if (existingStatus !== 'granted') {      const { status } = await Notifications.requestPermissionsAsync();      finalStatus = status;    }    if (finalStatus !== 'granted') {      return;    }    // Check if app was opened from notification (cold start)    await this.handleInitialNotification();    }  /**   * Setup the notification response listener   */  private setupNotificationResponseListener() {    // Remove any existing listener    if (this.responseListenerSubscription) {      this.responseListenerSubscription.remove();    }    // Add notification response listener (handles notification taps)    this.responseListenerSubscription = Notifications.addNotificationResponseReceivedListener(      (response) => {        const data = response.notification.request.content.data as NotificationData;        this.handleNotificationNavigation(data);      }    );  }  /**   * Handle initial notification when app is opened from killed state   */  private async handleInitialNotification() {    try {      // Get the last notification response (for cold start)      const lastNotificationResponse = await Notifications.getLastNotificationResponseAsync();      if (lastNotificationResponse) {        const data = lastNotificationResponse.notification.request.content.data as NotificationData;        // Store pending navigation for after authentication        this.pendingNavigation = () => this.handleNotificationNavigation(data);        // Try to execute immediately if navigation is ready        if (this.isNavigationReady) {          this.executePendingNavigation();        }      }    } catch (error) {      }  }  /**   * Handle navigation based on notification data   */  private handleNotificationNavigation(data: NotificationData) {    if (!data) {      return;    }    // If navigation is not ready, store as pending    if (!this.isNavigationReady) {      this.pendingNavigation = () => this.handleNotificationNavigation(data);      return;    }    try {      const { type, postId, chatId, userId, senderId } = data;      // Navigate based on notification type      switch (type) {        case 'like':        case 'comment':          if (postId) {            const params: Record<string, string> = {               fromNotification: 'true',              timestamp: Date.now().toString() // Ensure unique navigation            };            if (type === 'comment') {              params.scrollToComments = 'true';            }            // Use push for better navigation experience            router.push({              pathname: `/post/${postId}`,              params            });          } else {            this.navigateToNotifications();          }          break;        case 'message':          // For chat messages, navigate to the chat screen          const targetChatId = chatId || senderId; // Use chatId first, fallback to senderId          if (targetChatId) {            router.push({              pathname: `/chat/${targetChatId}`,              params: {                 fromNotification: 'true',                timestamp: Date.now().toString()              }            });          } else {            this.navigateToNotifications();          }          break;        case 'follow':          // For follow notifications, navigate to the follower's profile          if (userId || senderId) {            const targetUserId = userId || senderId;            router.push({              pathname: `/profile/${targetUserId}`,              params: {                 fromNotification: 'true',                timestamp: Date.now().toString()              }            });          } else {            this.navigateToNotifications();          }          break;        default:          this.navigateToNotifications();          break;      }    } catch (error) {      // Fallback to notifications screen on error      this.navigateToNotifications();    }  }  /**   * Navigate to notifications screen as fallback   */  private navigateToNotifications() {    try {      router.push({        pathname: '/(tabs)/notifications',        params: {           fromNotification: 'true',          timestamp: Date.now().toString()        }      });    } catch (error) {      // Last resort: go to home      router.replace('/(tabs)');    }  }  /**   * Set navigation ready state   */  setNavigationReady(ready: boolean) {    this.isNavigationReady = ready;    if (ready) {      // Execute pending navigation if any      this.executePendingNavigation();      // Execute any queued callbacks      this.navigationReadyCallbacks.forEach(callback => callback());      this.navigationReadyCallbacks = [];    }  }  /**   * Execute pending navigation   */  executePendingNavigation() {    if (this.pendingNavigation && this.isNavigationReady) {      const navigation = this.pendingNavigation;      this.pendingNavigation = null;      // Add a small delay to ensure the navigation stack is ready      setTimeout(() => {        navigation();      }, 500);    }  }  /**   * Queue a callback for when navigation is ready   */  onNavigationReady(callback: () => void) {    if (this.isNavigationReady) {      callback();    } else {      this.navigationReadyCallbacks.push(callback);    }  }  /**   * Test notification navigation (for development)   */  async testNotificationNavigation(type: 'like' | 'comment' | 'message' | 'follow') {    const testData: Record<string, NotificationData> = {      like: {        type: 'like',        postId: 'test-post-123',        userId: 'test-user-456',        username: 'TestUser'      },      comment: {        type: 'comment',        postId: 'test-post-789',        userId: 'test-user-012',        username: 'CommentUser'      },      message: {        type: 'message',        chatId: 'test-chat-345',        senderId: 'test-sender-678',        username: 'ChatUser'      },      follow: {        type: 'follow',        userId: 'test-follower-901',        username: 'FollowerUser'      }    };    const data = testData[type];    if (data) {      this.handleNotificationNavigation(data);    }  }  /**   * Get expo push token   */  async getExpoPushToken(): Promise<string | null> {    try {      const token = await Notifications.getExpoPushTokenAsync();      return token.data;    } catch (error) {      return null;    }  }  /**   * Schedule a local notification (for testing)   */  async scheduleLocalNotification(type: 'like' | 'comment' | 'message' | 'follow') {    const notifications: Record<string, { title: string; body: string; data: NotificationData }> = {      like: {        title: '‚ù§Ô∏è New Like',        body: 'TestUser liked your post',        data: {          type: 'like',          postId: 'test-post-123',          userId: 'test-user-456',          username: 'TestUser'        }      },      comment: {        title: 'üí¨ New comment on your post',        body: 'TestUser: Great post!',        data: {          type: 'comment',          postId: 'test-post-789',          userId: 'test-user-012',          username: 'CommentUser',          scrollToComments: 'true'        }      },      message: {        title: 'üí¨ New Message',        body: 'You have a new message from ChatUser',        data: {          type: 'message',          chatId: 'test-chat-345',          senderId: 'test-sender-678',          username: 'ChatUser'        }      },      follow: {        title: 'üë§ New Follower',        body: 'FollowerUser started following you',        data: {          type: 'follow',          userId: 'test-follower-901',          username: 'FollowerUser'        }      }    };    const notification = notifications[type];    if (notification) {      await Notifications.scheduleNotificationAsync({        content: {          title: notification.title,          body: notification.body,          data: notification.data,          sound: true,        },        trigger: null, // Show immediately      });      }  }  /**   * Cleanup the service   */  cleanup() {    if (this.responseListenerSubscription) {      this.responseListenerSubscription.remove();      this.responseListenerSubscription = null;    }    this.pendingNavigation = null;    this.isNavigationReady = false;    this.navigationReadyCallbacks = [];    }}// Export singleton instanceexport const notificationNavigationService = new NotificationNavigationService();export default notificationNavigationService;