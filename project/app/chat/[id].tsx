import React, { useEffect, useState, useRef } from 'react';import { useLocalSearchParams, useRouter } from 'expo-router';import { View, StyleSheet, Alert, ActivityIndicator, Text, AppState } from 'react-native';import ChatScreen from '@/components/chat/ChatScreen';import { apiService } from '../../lib/api';import { useAuth } from '../../context/AuthContext';import { useChatContext } from '../../context/ChatContext';import { Colors } from '../../constants/theme';import { fcmService } from '../../lib/fcmService';export default function IndividualChatScreen() {  const { id } = useLocalSearchParams();  const router = useRouter();  const { user } = useAuth();  const { refreshUnreadCounts, markChatAsRead: markChatAsReadContext } = useChatContext();  const [chatData, setChatData] = useState(null);  const [loading, setLoading] = useState(false);  const [isFromNotification, setIsFromNotification] = useState(false);  const lastAppStateRef = useRef(AppState.currentState);  useEffect(() => {    // Track current chat for notification suppression    if (id) {      fcmService.setCurrentChatId(id as string);      // Check if we navigated from a notification by checking navigation params      // When coming from notification, we should force refresh to get latest messages      const checkNotificationSource = () => {        // Check if app just became active (typical notification flow)        const currentAppState = AppState.currentState;        const wasInBackground = lastAppStateRef.current === 'background' || lastAppStateRef.current === 'inactive';        const isNowActive = currentAppState === 'active';        // If app just became active from background, or we can't go back, it's likely from notification        if ((wasInBackground && isNowActive) || !router.canGoBack()) {          setIsFromNotification(true);        }        lastAppStateRef.current = currentAppState;      };      checkNotificationSource();    }    loadChatData();    // Mark chat as read when entering (but don't refresh counts immediately)    if (user && id) {      markChatAsRead();    }    // Cleanup when leaving chat    return () => {      fcmService.setCurrentChatId(null);      // Only refresh counts when leaving, not when entering      if (user && id) {        markChatAsRead();        // Debounce the refresh to avoid multiple calls        setTimeout(() => {          refreshUnreadCounts();        }, 500);      }      setIsFromNotification(false);    };  }, [id, user]);  const markChatAsRead = async () => {    try {      // Call API to mark chat as read (reset unread count on server)      await apiService.markChatAsRead(id as string);      // Update local context to sync with bottom navigation (use 0 for read)      markChatAsReadContext(id as string, 0);      // Don't refresh counts immediately - let it happen naturally    } catch (error) {      // Don't let this error break the chat functionality    }  };  const loadChatData = async () => {    if (!user || !id) return;    // Optimistic loading - set basic chat data immediately to avoid loading screen    setChatData({      id: id as string,      name: 'Loading...',      username: 'Loading...',      avatar: '',      isOnline: false,      lastSeen: 'recently',      lastSeenText: 'Last seen recently',      userId: 'unknown',    });    setLoading(false);    try {      // First, try to get chat data from user's chats list      const userChats = await apiService.getUserChats(user.id);      let chatFromList = null;      if (Array.isArray(userChats)) {        chatFromList = userChats.find((chat: any) => String(chat.id) === String(id));      } else if (userChats && typeof userChats === 'object') {        const chatsArray = (userChats as any).data || (userChats as any).chats || [];        if (Array.isArray(chatsArray)) {          chatFromList = chatsArray.find((chat: any) => String(chat.id) === String(id));        }      }      if (chatFromList) {        // Use data from the chats list        let participantUserId = chatFromList.userId;        // If userId is not available in chat list, try to extract from participants        if (!participantUserId || participantUserId === 'unknown') {          if (chatFromList.participants && Array.isArray(chatFromList.participants)) {            const otherParticipant = chatFromList.participants.find(              (p: any) => p.userId !== user.id && p.user_id !== user.id            );            participantUserId = otherParticipant?.userId || otherParticipant?.user_id || otherParticipant?.id;          }        }        setChatData({          id: chatFromList.id,          name: chatFromList.name || chatFromList.username || 'User',          username: chatFromList.username || chatFromList.name || 'User',          avatar: chatFromList.avatar || '',          isOnline: chatFromList.isOnline || false,          lastSeen: chatFromList.lastSeen || 'recently',          lastSeenText: chatFromList.lastSeenText || (chatFromList.isOnline ? 'Online' : 'Last seen recently'),          userId: participantUserId || 'unknown',        });      } else {        // Fallback: try the getChatById approach        try {          const chat = await apiService.getChatById(id as string);          if (chat && chat.participants) {            // Find the other user in the chat            const otherParticipant = chat.participants.find(              (p: any) => p.userId !== user.id            );            if (otherParticipant) {              const participantUserId = otherParticipant.userId || otherParticipant.user_id || otherParticipant.id;              if (participantUserId) {                // Fetch the full profile of the other user                const otherUserData = await apiService.getUserProfileSafe(participantUserId);                if (otherUserData) {                  setChatData({                    id: chat.id,                    name: otherUserData.username || 'User',                    username: otherUserData.username || 'User',                    avatar: otherUserData.avatar_url || otherUserData.avatar || '',                    isOnline: false,                    lastSeen: 'recently',                    lastSeenText: 'Last seen recently',                    userId: otherUserData.id,                  });                  return;                }              }            }          }        } catch (detailedError) {          // getChatById failed, continue with fallback        }        // Final fallback with basic chat data        setChatData({          id: id as string,          name: 'Chat',          username: 'Chat',          avatar: '',          isOnline: false,          lastSeen: 'recently',          lastSeenText: 'Last seen recently',          userId: 'unknown',        });      }    } catch (error) {      // Fallback in case of any error      setChatData({        id: id as string,        name: 'Chat',        username: 'Chat',        avatar: '',        isOnline: false,        lastSeen: 'recently',        lastSeenText: 'Last seen recently',        userId: 'unknown',      });    } finally {      setLoading(false);    }  };  const handleBack = () => {    if (router.canGoBack()) {      router.back();    } else {      router.push('/(tabs)/chats');    }  };  const handleUserProfile = (userId: string) => {    if (userId && userId !== 'unknown' && userId !== 'undefined' && userId.trim() !== '') {      router.push(`/profile/${userId}`);    } else {      Alert.alert(        'Profile Unavailable',         'Unable to open user profile. The user information is not available at the moment.',        [{ text: 'OK', style: 'default' }]      );    }  };  return (    <View style={styles.container}>      {loading ? (        <View style={styles.loadingContainer}>          <ActivityIndicator size="large" color={Colors.primary} />          <Text style={styles.loadingText}>Loading chat...</Text>        </View>      ) : chatData ? (        <ChatScreen           chatData={chatData}          onBack={handleBack}          onUserProfile={handleUserProfile}          forceInitialRefresh={isFromNotification}        />      ) : (        <View style={styles.errorContainer}>          <Text style={styles.errorText}>Failed to load chat</Text>        </View>      )}    </View>  );}const styles = StyleSheet.create({  container: {    flex: 1,    backgroundColor: Colors.background,  },  loadingContainer: {    flex: 1,    justifyContent: 'center',    alignItems: 'center',  },  loadingText: {    color: Colors.textSecondary,    marginTop: 16,    fontSize: 16,  },  errorContainer: {    flex: 1,    justifyContent: 'center',    alignItems: 'center',    backgroundColor: Colors.background,  },  errorText: {    color: Colors.textSecondary,    fontSize: 16,    marginBottom: 16,  },});