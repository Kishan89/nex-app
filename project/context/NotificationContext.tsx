// context/NotificationContext.tsximport React, { createContext, useContext, useState, useEffect } from 'react';import { AppState, AppStateStatus, DeviceEventEmitter } from 'react-native';import { FirebaseMessagingTypes } from '@react-native-firebase/messaging';import { fcmService, FCMNotificationData } from '@/lib/fcmService';import { useAuth } from './AuthContext';import { router } from 'expo-router';interface NotificationState {  visible: boolean;  title: string;  body: string;  data?: FCMNotificationData;  avatar?: string;  username?: string;}interface NotificationContextType {  notification: NotificationState;  showNotification: (title: string, body: string, data?: FCMNotificationData, avatar?: string, username?: string) => void;  hideNotification: () => void;  handleNotificationPress: () => void;  showInAppNotification: (title: string, body: string, data?: FCMNotificationData, avatar?: string, username?: string) => void;}const NotificationContext = createContext<NotificationContextType | undefined>(undefined);export const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {  const { user } = useAuth();  const [notification, setNotification] = useState<NotificationState>({    visible: false,    title: '',    body: '',    data: undefined,    avatar: undefined,    username: undefined,  });  const showNotification = (title: string, body: string, data?: FCMNotificationData, avatar?: string, username?: string) => {    setNotification({      visible: true,      title,      body,      data,      avatar,      username,    });  };  const showInAppNotification = (title: string, body: string, data?: FCMNotificationData, avatar?: string, username?: string) => {    // FCM service now handles all notifications    // This method is deprecated - FCM service emits events directly    };  // Register global callback for FCM service  useEffect(() => {    (global as any).__showNotification = showNotification;    return () => {      delete (global as any).__showNotification;    };  }, []);  // FCM is initialized in app/_layout.tsx to prevent duplicate initialization  // This context only handles notification state management  // Handle app state changes  useEffect(() => {    const handleAppStateChange = (nextAppState: AppStateStatus) => {      if (nextAppState === 'background' || nextAppState === 'inactive') {        // Hide notification when app goes to background        hideNotification();      }    };    const subscription = AppState.addEventListener('change', handleAppStateChange);    return () => subscription?.remove();  }, []);  const hideNotification = () => {    setNotification(prev => ({      ...prev,      visible: false,    }));  };  const handleNotificationNavigation = (data: FCMNotificationData) => {    const { postId, userId, type, chatId, senderId } = data;    try {      if (type === 'message' && (chatId || senderId)) {        const targetChatId = chatId || senderId;        // Use replace to prevent stacking multiple screens        router.replace(`/chat/${targetChatId}`);      } else if ((type === 'like' || type === 'comment') && postId) {        const params: Record<string, string> = { fromNotification: 'true' };        if (type === 'comment') {          params.scrollToComments = 'true';        }        // Use replace to prevent stacking multiple screens        router.replace({          pathname: `/post/${postId}`,          params        });      } else if (type === 'follow' && (userId || senderId)) {        const targetUserId = userId || senderId;        // Use replace to prevent stacking multiple screens        router.replace({          pathname: `/profile/${targetUserId}`,          params: { fromNotification: 'true' }        });      } else {        }    } catch (error) {      router.replace('/(tabs)');    }  };  const handleNotificationPress = () => {    if (notification.data) {      handleNotificationNavigation(notification.data);    }    hideNotification();  };  return (    <NotificationContext.Provider      value={{        notification,        showNotification,        hideNotification,        handleNotificationPress,        showInAppNotification,      }}    >      {children}    </NotificationContext.Provider>  );};export const useNotification = () => {  const context = useContext(NotificationContext);  if (!context) {    throw new Error('useNotification must be used within NotificationProvider');  }  return context;};export default NotificationContext;